---
title: Clojure-style Agents in Scala - an alternative to Actors
created: !!timestamp '2014-02-22 9:00:00'
nolinkback: true
tags:
    - scala
    - type systems
    - traits
    - scalaz
    - scalaz-streaming
    - agents
    - concurrency
---

{% mark excerpt -%}

I was recently introduced to the [scalaz-stream](https://github.com/scalaz/scalaz-stream) library by the excellent blog post [Actors are Overly Nondeterministic](http://pchiusano.blogspot.in/2013/09/actors-are-overly-nondeterminstic.html). I decided to take a look at them, and I realize they have a lot to offer.

One of the cools things I noticed could be built with them is Clojure-style Agents. But Agents implemented using scalaz-stream are actually more general than clojure agents - asynchronous multithreaded processing is not required. If you want to run agents in a separate thread, using a message queue for communication, you can. But you can also run them in a single thread if that's more efficient. Using scalaz-stream, we can actually generalize over the specific dispatch method.

{%- endmark %}

# scalaz.concurrent.Process

A `Process[F[_], T]` is a stream of values of type `T`, but which has the ability to make external requests of type `F[_]`. So for example, a `Process` might be a stream of `Int` objects, but while processing the `Int` objects it could also make requests return an `Option[X]` to assist in the computation.

I'm going to avoid more abstract nonsense and give an example. My working example will be building a conversion rate tracker, so I'll define the basic relevant data types:

    sealed trait Event
    case object Display extends Event
    case object Conversion extends Event

The `Display` object represents the display of an ad to a user, while `Conversion` represents the user clicking on the ad.

An event stream will be an object of type `Process[F[_], Event]`. The simplest way to build one is as follows:

    val testSeq: Process[Nothing,Event] = Process.emitSeq(Seq[Event](Display,Conversion,Display,Display))

This is little more than a wrapper around an underlying `Seq`. In fact, it literally evaluates to exactly that:

    scala> testSeq
    res2: scalaz.stream.Process[Nothing,ScalazStreaming.Event] = Emit(List(Display, Conversion, Display, Display),Halt(scalaz.stream.Process$End$))

The underlying monad here is `Nothing` - i.e., there is no monadic effect in play here.

## An infinite stream

We might also want to play with an infinite stream. Defining this takes a bit more work:

    import scalaz.stream._
    import scalaz.stream.io._
    import scalaz.concurrent.Task

    val rnd = new Random
    val conversionRate = 0.10

    def simulatedEvent: Process[Task,Event] = Process.await(Task.delay({ () }))(recv = _ => {
      if (rnd.nextDouble < conversionRate) {
        Process.emitSeq( Seq(Display,Conversion) )
      } else {
        Process.emit(Display)
      }
    })

The `simulatedEvent` function represents a single lazily-evaluated event where we displayed an ad to a user, following which the user may or may not have converted. 90% of the time, we will see the following:

    scala> simulatedEvent.toSeq
    Seq(Display)

10% of the time we get the following:

    scala> simulatedEvent.toSeq
    Seq(Display, Conversion)

Now to create an infinite *stream* of events, we simply use the `repeat` method:

    def eventStream = simulatedEvent.repeat

## Lazy vs String Evaluation

Scalaz streams are *not* lazy by default - you need to be very careful about how they work.

We might consider the following implementation of `simulatedEvent`:

    def simulatedEventStrict = if (rnd.nextDouble < conversionRate) {
      Process.emit( Display ) ++ Process.emit(Conversion)
    } else {
      Process.emit(Display)
    }

Calling `simulatedEventStrict.repeat` results in a `java.lang.StackOverflowError` exception. Evaluating the next elements lazily is why we used `Process.await`.

# Agents

We define an agent similarly to the clojure style. An agent is merely a piece of data (the state) together with a function that takes a message and updates the state.

    trait Agent[T, A <: Agent[T,A]] {
      def receive(d: T): A
    }

The type signature is fairly complicated, but an example will clear things up. We'll build a `StatisticsCalculator`, which is a class that receives an event (either a `Display` or a `Conversion`) and updates it's statistics:

    case class StatisticsCalculator(displays: Long, conversions: Long) extends Agent[Event, StatisticsCalculator] {
      def send(e: Event): StatisticsCalculator = e match {
        case Display => this.copy(displays=displays+1)
        case Conversion => this.copy(conversions=conversions+1)
      }
    }

This is more or less how we would build a mutable statistics counter - the only difference is that this version is purely functional. The complicated type signature is necessary to ensure that `send` returns a `StatisticsCalculator` rather than an `Agent[Event,StatisticsCalculator]`.

For those familiar with Clojure agents, the `send` method should be considered analogous to Clojure's send.

## scan - a streaming version of cumulative sum

The `Process` type provides a method called `scan`:

    def scan[B](b: B)(f: (B,O) => B): Process[F,B]

The `scan` method is sort of a cumulative fold. Rather than simply providing the result of folding the entire stream, it provides the intermediate results along the way as well. I.e., suppose `ones` were a stream repeating an infinite sequence of `1`. Then:

    ones.scan(0)( (x, y) => x+y )

would return the stream `0,1,2,3,...`.

Using `scan`, we can define a `runAgent` function:

    def runAgent[F[_], T, A <: Agent[T,A]](process: Process[F,T], initialState: =>A): Process[F,A]
        = process.scan(initialState)( (a, t) => a.send(t) )

That's a complicated type signature, but only due to the signature of the `Agent`.

## Computing the history of the agent

If we now apply the `runAgent` function, we get a stream of agent values:

    scala> val testSeq: Process[Nothing,Event] = Process.emitSeq(Seq[Event](Display,Conversion,Display,Display))

    scala> runAgent(testSeq, StatisticsCalculator(0,0)).toSeq
    Seq[com.chrisstucchio.spire_examples.ScalazStreaming.StatisticsCalculator] = Vector(StatisticsCalculator(0,0), StatisticsCalculator(1,0), StatisticsCalculator(1,1), StatisticsCalculator(2,1), StatisticsCalculator(3,1))

So using the `Agent`, we've synchronously run a calculation on a sequence of events. At the start, the `Agent` has the state `StatisticsCalculator(0,0)`. After seeing the first event (a `Display`), it's state is `StatisticsCalculator(1,0)` representing that it saw a single `Display` and 0 `Conversions`. Schematically, we've done the following:

    Input data: ()   , Display, Conversion, Display, Display
    State:      (0,0), (1,0),   (1,1),      (2,1),   (3,1)

So far this is nothing special - it's just a fancy way of simulating stateful code in a purely functional system. We haven't actually done anything yet.


# Changing the execution model

In the previous section, we merely used agents to run a *purely functional* computation. The function `Process.emitSeq` did little more than put a wrapper around a standard scala `Seq`. The `runAgent` function merely ran a `fold`-like operation.

However, we can also run an infinite calculation using the *exact same code*. Recall the `eventStream`:

    def eventStream: Process[Task,Event] = simulatedEvent.repeat

Note that the type of this is now `Process[Task,Event]` instead of `Process[Nothing,Event]`. I.e., there is an effectful monad underlying this stream.

    scala> runAgent(eventStream, StatisticsCalculator(0,0))
    res3: scalaz.stream.Process[scalaz.concurrent.Task,ScalazStreaming.StatisticsCalculator] = Emit(List(StatisticsCalculator(0,0)),Await(scalaz.concurrent.Task@5fd243ea,<function1>,Halt(scalaz.stream.Process$End$),Halt(scalaz.stream.Process$End$)))

This looks like a little bit more than a wrapper around a `Seq`. The result of `runAgent` on the `eventStream` is now the first object, together with a closure representing how to continue the computation. If we want to actually run the computation, we need to call the `.run` method. But that will be an infinite computation with no side effects, so lets do something more interesting. Lets produce some side effects:

    scala> val s = runAgent(eventStream, StatisticsCalculator(0,0)).map(x => println(x))
    s: scalaz.stream.Process[scalaz.concurrent.Task,Unit] = Emit(List(()),Await(scalaz.concurrent.Task@7150c54a,<function1>,Halt(scalaz.stream.Process$End$),Halt(scalaz.stream.Process$End$)))

We've produced a value of type `Process[Task,Unit]` as expected, but we've also generated a side effect. The following was printed to stdout:

    StatisticsCalculator(0,0)

To run the stream, we use the `.run` method, which returns a `Task[Unit]`. For those unfamiliar with `scalaz.concurrent.Task`, it's the scalaz alternative to `scala.concurrent.Future`. So running the `Process[Task,Unit]` is basically a way of sequencing a bunch of `Future`-like objects together.

The `Future` (oops `Task`) can then be run with it's own `.run` method (equivalent to `Await.ready(future, duration)` from Akka):

    scala> s.run.run
    StatisticsCalculator(0,0)
    StatisticsCalculator(1,0)
    StatisticsCalculator(2,0)
    StatisticsCalculator(2,1)
    StatisticsCalculator(3,1)
    ...etc...

(There are some interesting differences between `Future` and `Task`. I'll discuss them in another post.)

# Testing is easy

One major advantage of this is that testing becomes trivially easy. If I want to test an `Agent`, I simply generate input as a `Seq`:

    Process.emitSeq(Seq[Event](Display,Conversion,Display,Display))

and then check whether the output matches the desired sequence:

    assert(runAgent(testSeq, StatisticsCalculator(0,0)).toSeq === Seq(StatisticsCalculator(0,0), StatisticsCalculator(1,0), StatisticsCalculator(1,1), StatisticsCalculator(2,1), StatisticsCalculator(3,1)))

This separates business logic from implementation details. This is a lot easier and faster than testing Akka code. Testing Akka actors typically involves spinning up actor systems, and code is littered with `expectMsgPf(250 milliseconds)` and similar things.
